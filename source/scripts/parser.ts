/**
 * This is the parser, which takes the tokens generated by the lexer
 * and validates their ordering with the provided grammar.
 * Produces a CST.
 * Traverse inorder DFS.
 * Top-down recursive descent parser on an LL(1) grammar.
 */

module TSC {
    export class Parser {

        currentToken: number; // the index of the current token we're looking at
        tokenList;

        constructor() {}

        public init(tokens) {
            this.tokenList = tokens;
            // Set current token to the first token in the list
            this.currentToken = 0;
        }

        // ---------------------------- NON-TERMINALS -------------------------------- //
        // Due to the brilliance of JavaScript's short-circuit evaluation, our
        // lives are made way easier. i.e. false && (anything) is false, JS
        // will not eval anything after the first expression if it is false. Bless
        
        public parse(tokens) {
            console.log(tokens);
            this.init(tokens);
            if(this.parseProgram()){
                // do something
            }
        }

        public parseProgram(): boolean {
            if(this.parseBlock() && this.matchEOP){
                return true;
            }
            return false;
        }

        public parseBlock(): boolean {
            if(this.matchLbrace() && this.parseStatementList() && this.matchRbrace()){
                return true;
            }
            return false;
        }

        public parseStatementList() {
            if(this.parseStatement() && this.parseStatementList()){
                console.log("jesus christ it's jesus christ");
                return true;
            }
            // epsilon... return to parseBlock
            else{
                console.log("jesus christ it's jason bourne");
                return true;
            }
        }

        public parseStatement() {
            if(this.parsePrintStatement() || this.parseAssignmentStatement() || this.parseVarDecl() || this.parseWhileStatement() || this.parseIfStatement() || this.parseBlock()){
                return true;
            }
            return false;
        }

        public parsePrintStatement() {
            if(this.matchPrint() && this.matchLparen() && this.parseExpr() && this.matchRparen()){
                return true;
            }
            return false;
        }

        public parseAssignmentStatement() {
            if(this.parseId() && this.matchAssign() && this.parseExpr()){
                return true;
            }
            return false;
        }

        public parseVarDecl() {
            if(this.matchType() && this.parseId()){
                return true;
            }
            return false;
        }

        public parseWhileStatement() {
            if(this.matchWhile() && this.parseBooleanExpr() && this.parseBlock()){
                return true;
            }
            return false;
        }

        public parseIfStatement() {
            if(this.matchIf() && this.parseBooleanExpr() && this.parseBlock()){
                return true;
            }
            return false;
        }

        public parseExpr() {
            if(this.matchPrint()){
                return true;
            }
            return false;
        }

        public parseIntExpr() {

        }

        public parseStringExpr() {

        }

        public parseBooleanExpr() {

        }

        public parseId() {

        }

        public parseCharList() {

        }



        // ---------------------------- TERMINALS -------------------------------- //
        // if next token we're looking at match to a terminal symbol, advance the current token
        // if error, break out of parse

        public matchEOP() {

        }

        public matchLbrace(): boolean {
            if(this.tokenList[this.currentToken].type == TokenType.TLbrace){
                this.currentToken++;
                return true;
            }
            else{
                return false;
            }
        }

        public matchRbrace() {
            if(this.tokenList[this.currentToken].type == TokenType.TRbrace){
                this.currentToken++;
                return true;
            }
            else{
                return false;
            }
        }

        public matchPrint() {
            if(this.tokenList[this.currentToken].type == TokenType.TPrint){
                this.currentToken++;
                return true;
            }
            else{
                return false;
            }
        }

        public matchLparen() {
            if(this.tokenList[this.currentToken].type == TokenType.TLparen){
                this.currentToken++;
                return true;
            }
            else{
                return false;
            }
        }

        public matchRparen() {
            if(this.tokenList[this.currentToken].type == TokenType.TRparen){
                this.currentToken++;
                return true;
            }
            else{
                return false;
            }
        }

        public matchAssign() {

        }

        public matchWhile() {

        }

        public matchIf() {

        }

        public matchQuote() {

        }

        public matchType() {

        }

        public matchChar() {

        }

        public matchSpace() {

        }
        
        public matchDigit() {

        }

        public matchBoolop() {

        }

        public matchBoolval() {

        }

        public matchIntop() {

        }

    }
}