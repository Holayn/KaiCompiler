/**
 * This is the parser, which takes the tokens generated by the lexer
 * and validates their ordering with the provided grammar.
 * Produces a CST.
 * Traverse inorder DFS.
 * Top-down recursive descent parser on an LL(1) grammar.
 */

module TSC {
    export class Parser {

        currentToken: number; // the index of the current token we're looking at
        tokenList; // list of tokens passed from lexer
        log; // log of parser
        error: boolean;

        constructor() {}

        public init(tokens) {
            this.tokenList = tokens;
            // Set current token to the first token in the list
            this.currentToken = 0;
            this.log = [];
            this.error = false;
        }

        // ---------------------------- NON-TERMINALS -------------------------------- //
        // Due to the brilliance of JavaScript's short-circuit evaluation, our
        // lives are made way easier. i.e. false && (anything) is false, JS
        // will not eval anything after the first expression if it is false. Praise!
        // Top-down recursive descent left->right leftmost derivation parser.
        // I think the logic of the code is self-documenting if one refers to 
        // the grammar of the language.
        
        public parse(tokens) {
            console.log(tokens);
            this.init(tokens);
            if(this.parseProgram()){
                console.log("PARSER: success!");
            }
            else{
                console.log("PARSER: error");
            }
            console.log(this.log);
        }

        public parseProgram(): boolean {
            if(this.parseBlock()){
                if(this.matchToken(TokenType.TEop)){
                    return true;
                }
            }
            return false;
        }

        public parseBlock(): boolean {
            // if(this.error){
            //     return false;
            // }
            if(this.matchToken(TokenType.TLbrace)){
                this.log.push("VALID - Expecting Block, found Block");
                this.consumeToken(TokenType.TLbrace);
                if(this.parseStatementList()){
                    if(this.matchToken(TokenType.TRbrace)){
                        this.consumeToken(TokenType.TRbrace);
                        return true;
                    }
                }
            }
            return false;
        }

        public parseStatementList() {
            console.log("DEPREPRPERPER");
            if(this.parseStatement() && this.parseStatementList()){
                console.log("hahaDEPREPRPERPER");
                return true;
            }
            // epsilon... return to parseBlock
            else{
                return true;
            }
        }

        public parseStatement() {
            console.log("PARSER: parsing a statement");
            if(this.parsePrintStatement() || this.parseAssignmentStatement() || this.parseVarDecl() || this.parseWhileStatement() || this.parseIfStatement() || this.parseBlock()){
                return true;
            }
            return false;
        }

        public parsePrintStatement() {
            console.log("PARSER: parsing a print");
            // this is why we need to sep match and consume
            if(this.matchToken(TokenType.TPrint)){
                console.log("PARSER: printstatement found");
                this.log.push("VALID - Expecting Statement, found PrintStatement");
                this.consumeToken(TokenType.TPrint);
                if(this.matchToken(TokenType.TLparen)){
                    this.consumeToken(TokenType.TLparen);
                    if(this.parseExpr()){
                        if(this.matchToken(TokenType.TRparen)){
                            this.consumeToken(TokenType.TRparen);
                        }
                    }
                    return true;
                }
            }
            return false;
        }

        public parseAssignmentStatement() {
            console.log("PARSER: parsing a assignmentstatement");
            if(this.matchToken(TokenType.TId)){
                this.log.push("VALID - Expecting Statement, found AssignmentStatement");
                this.consumeToken(TokenType.TId);
                if(this.matchToken(TokenType.TAssign)){
                    this.consumeToken(TokenType.TAssign);
                    if(this.parseExpr()){
                        return true;
                    }
                    else{
                        this.error = true;
                        this.log.push("ERROR - Expecting Expr, found " + this.tokenList[this.currentToken].type);
                    }
                }
                else{
                    this.error = true;
                    this.log.push("ERROR - Expecting TAssign, found " + this.tokenList[this.currentToken].type);
                }
            }
            return false;
        }

        public parseVarDecl() {
            console.log("PARSER: parsing a vardecl");
            if(this.matchToken(TokenType.TType)){
                console.log("PARSER: vardecl found");
                this.log.push("VALID - Expecting Statement, found VarDecl");
                this.consumeToken(TokenType.TType);
                if(this.parseId()){
                    return true;
                }
            }
            return false;
        }

        public parseWhileStatement() {
            console.log("PARSER: parsing a whilestatement");
            if(this.matchToken(TokenType.TWhile)){
                console.log("PARSER: whilestatement found");
                this.log.push("VALID - Expecting Statement, found VarDecl");
                this.consumeToken(TokenType.TWhile);
                if(this.parseBooleanExpr()){
                    if(this.parseBlock()){
                        return true;
                    }
                    this.error = true;
                    this.log.push("ERROR - Expecting TLbrace, found " + this.tokenList[this.currentToken].type);
                }
                else{
                    this.error = true;
                    this.log.push("ERROR - Expecting BooleanExpr, found " + this.tokenList[this.currentToken].type);
                }
            }
            return false;
        }

        public parseIfStatement() {
            console.log("PARSER: parsing an ifstatement");
            if(this.matchToken(TokenType.TIf) && this.parseBooleanExpr() && this.parseBlock()){
                console.log("PARSER: ifstatement found");
                return true;
            }
            return false;
        }

        public parseExpr() {
            console.log("PARSER: parsing an expr");
            // if(this.parseIntExpr() || this.parseStringExpr() || this.parseBooleanExpr() || this.parseId()){
            if(this.parseBooleanExpr()){
                console.log("PARSER: expr found");
                return true;
            }
            else if(this.parseIntExpr()){
                console.log("PARSER: expr found");
                return true;
            }
            else if(this.parseId()){
                console.log("PARSER: expr found");
                return true;
            }
            else if(this.parseStringExpr()){
                console.log("PARSER: expr found");
                return true;
            }
            return false;
        }

        public parseIntExpr() {
            console.log("PARSER: parsing an intexpr");
            // in case after a digit an intop is not found, we accept the digit
            if(this.matchToken(TokenType.TDigit)){
                this.consumeToken(TokenType.TDigit);
                // if(this.matchToken(TokenType.TIntop) && this.parseExpr()){
                //     console.log("PARSER: intexpr (digit op expr) found");
                //     return true;
                // }
                // else{
                //     console.log("PARSER: intexpr (digit) found");
                //     return true;
                // }
                return true;
            }
            return false;
        }

        public parseStringExpr() {
            console.log("PARSER: parsing a stringexpr");
            if(this.matchToken(TokenType.TQuote) && this.parseCharList() && this.matchToken(TokenType.TQuote)){
                console.log("PARSER: stringexpr found");
                return true;
            }
            return false;
        }

        public parseBooleanExpr() {
            console.log("PARSER: parsing a booleanexpr");
            if(this.matchToken(TokenType.TLparen)){
                this.log.push("VALID - Expecting Expr, found BooleanExpr");
                console.log("PARSER: booleanexpr found");
                this.consumeToken(TokenType.TBoolval);
                if(this.parseExpr()){
                    if(this.matchToken(TokenType.TBoolop)){
                        this.consumeToken(TokenType.TBoolval);
                        if(this.parseExpr()){
                            if(this.matchToken(TokenType.TRparen)){
                                return true;
                            }
                            else{
                                this.log.push("ERROR - Expecting TBoolval, found " + this.tokenList[this.currentToken].type);
                            }
                        }
                    }
                    else{
                        this.log.push("ERROR - Expecting TBoolop, found " + this.tokenList[this.currentToken].type);
                        return false;
                    }
                }
            }
            else if(this.matchToken(TokenType.TBoolval)){
                this.log.push("VALID - Expecting Expr, found BooleanExpr");
                this.consumeToken(TokenType.TBoolval);
                console.log("PARSER: booleanexpr found");
                return true;
            }
            return false;
        }

        public parseId() {
            console.log("PARSER: parsing an id");
            if(this.matchToken(TokenType.TId)){
                this.consumeToken(TokenType.TId);
                console.log("PARSER: id found");
                return true;
            }
            return false;
        }

        public parseCharList() {
            console.log("PARSER: parsing a charlist");
            // spaces are treated as chars for me
            if(this.matchToken(TokenType.TChar) && this.parseCharList()){
                console.log("PARSER: charlist found");
                return true;
            }
            else{
                // epsilon
                return true;
            }
        }



        // ---------------------------- TERMINALS -------------------------------- //
        // if next token we're looking at match to a terminal symbol, advance the current token
        // if error, break out of parse

        // Matches to passed token type
        public matchToken(token: TokenType) {
            // Check if there has been an error. If so, stop
            // if(this.error){
            //     return false;
            // }
            console.log("PARSER: testing match of " + this.tokenList[this.currentToken].type + " to token: " + token);
            if(this.tokenList[this.currentToken].type == token){
                console.log("PARSER: TOKEN " + token + " found");
                return true;
            }
            // maybe don't have invalid here?
            // this.log.push("INVALID - Expecting " + token + ", found " + this.tokenList[this.currentToken].type);
            return false;
        }

        // Consumes a token
        public consumeToken(token: TokenType) {
            if(this.tokenList[this.currentToken].type == token){
                console.log("PARSER: CONSUME TOKEN " + token);
                this.log.push("VALID - Expecting " + token + ", found " + this.tokenList[this.currentToken].type);
                this.currentToken++;
            }
        }
    }
}