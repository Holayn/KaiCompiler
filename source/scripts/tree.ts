module TSC {
    
        /**
         * Implementation of a Tree to represent the CST generated by the Parser
         */
        export class Tree {
            // root of the tree
            root: TreeNode;
            // current parent node we are looking at
            curr: TreeNode;
    
            constructor(){
                this.curr = null;
                this.root = null;
            }

            /**
             * Adds non-terminal node
             */
            public addNTNode(production: Production, lineNumber: number, colNumber: number){
                let node = new NonTerminalTreeNode(production);
                node.lineNumber = lineNumber;
                node.colNumber = colNumber;
                if(this.root == null){
                    this.root = node;
                    this.curr = node;
                    return;
                }
                // set parent
                node.parent = this.curr;
                // add to children of curr node
                this.curr.children.push(node);
                this.descendTree();
            }

            /**
             * Adds terminal node
             */
            public addTNode(token: Token, lineNumber: number, colNumber: number){
                let node = new TerminalTreeNode(token);
                node.lineNumber = lineNumber;
                node.colNumber = colNumber;
                if(this.root == null){
                    this.root = node;
                    this.curr = node;
                    return;
                }
                // set parent
                node.parent = this.curr;
                // add to children of curr node
                this.curr.children.push(node);
                // we don't descend tree here because terminal nodes are always leaf nodes
            }

            /**
             * Add general node
             */
            public addNode(input: any){
                let node = new GeneralTreeNode(input);
                if(this.root == null){
                    this.root = node;
                    this.curr = node;
                    return;
                }
                // set parent
                node.parent = this.curr;
                // add to children of curr node
                this.curr.children.push(node);
                this.descendTree();
            }

            /**
             * Sets current node to look at as the latest child
             */
            public descendTree(){
                if(this.curr == null){
                    return;
                }
                let latestChild = this.curr.children[this.curr.children.length-1];
                this.curr = latestChild;
            }

            /**
             * Sets current node to look at as the parent of the current node
             */
            public ascendTree(){
                this.curr = this.curr.parent;
            }

            /**
             * Prints the tree in dfs for CST display
             */
            public traverseTreeCST(treantTree){
                let tree: Array<String> = [];
                let level: number = 0;
                if(this.root != null){
                    this.DFSCST(this.root, level, tree, "", treantTree['nodeStructure'].children);
                }
                // Return array of nodes and tree config
                return {"tree": tree, "treant": treantTree};
            }

            /**
             * Prints the tree in dfs for AST display
             */
            public traverseTreeAST(treantTree){
                let tree: Array<String> = [];
                let level: number = 0;
                if(this.root != null){
                    this.DFSAST(this.root, level, tree, "", treantTree['nodeStructure'].children);
                }
                // Return array of nodes and tree config
                return {"tree": tree, "treant": treantTree};
            }
            
            /**
             * Helper for traverseTreeCST
             */
            private DFSCST(node, level, tree, dash, treantTree){
                let child = {};
                if(node.value instanceof Token){
                    tree.push(dash + "[" + node.value.value + "]")
                    // Add new node to children array passed
                    // Pass reference to new children array to next call
                    child = {
                        text: { name: "[" + node.value.value + "]" },
                        children: []
                    }
                    treantTree.push(child);
                }
                else{
                    tree.push(dash + "<" + node.value + ">")
                    // Add new node to children array passed
                    // Pass reference to new children array to next call
                    child = {
                        text: { name: "<" + node.value + ">" },
                        children: []
                    }
                    treantTree.push(child);
                }
                for(var i=0; i<node.children.length; i++){
                    // to next call of DFS, increase level, pass the tree array, increase the dash by one dash, and pass
                    // the reference to the next children array
                    this.DFSCST(node.children[i], level + 1, tree, dash + "-", child['children']);
                }
            }

            /**
             * Helper for traverseTreeAST
             */
            private DFSAST(node, level, tree, dash, treantTree){
                let child = {};
                // Check if null to find appropriate value to place in tree
                // Add new node to children array passed
                // Pass reference to new children array to next call
                if(node.value.value != null){
                    tree.push(dash + node.value.value);
                    child = {
                        text: { name: node.value.value + " " },
                        children: []
                    }
                }
                else{
                    tree.push(dash + node.value);
                    child = {
                        text: { name: node.value + " " },
                        children: []
                    }
                }
                treantTree.push(child);
                for(var i=0; i<node.children.length; i++){
                    // to next call of DFS, increase level, pass the tree array, increase the dash by one dash, and pass
                    // the reference to the next children array
                    this.DFSAST(node.children[i], level + 1, tree, dash + "-", child['children']);
                }
            }
        }
    
        /**
         * Implementation of a TreeNode that makes up a Tree
         */
        export abstract class TreeNode {
            value: any;
            // pointer to parent of this node
            parent: TreeNode;
            // the children this node points to
            children = [];
            constructor(value: any){
                this.value = value;
            }
        }
    
        /**
         * A TreeNode that represents NonTerminals
         */
        export class NonTerminalTreeNode extends TreeNode {
            value: Production;
            lineNumber: number;
            colNumber: number;
            super(value: Production){
                this.value = value;
            }
        }
    
        /**
         * A TreeNode that represents Terminals
         * Actually, Terminals don't need to store line and col numbers, as 
         * the tokens themselves store them
         */
        export class TerminalTreeNode extends TreeNode {
            value: Token;
            lineNumber: number;
            colNumber: number;
            super(value: Token){
                this.value = value;
            }
        }

        /**
         * A TreeNode that represents any value
         * General tree nodes don't need to hold information such as line numbers and col numbers
         * since they make up the AST.
         */
        export class GeneralTreeNode extends TreeNode {
            value: any;
            super(value: any){
                this.value = value;
            }
        }
    }