<!DOCTYPE HTML>
<html>
<head>
    <title>Kompailer</title>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <link rel="stylesheet" type="text/css" href="dist/styles/compiler.css" />
	<!-- <link rel="stylesheet" href="dist/styles/bootstrap.min.css"> -->
	<!--Import Google Icon Font-->
	<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
	<!--Import materialize.css-->
	<link type="text/css" rel="stylesheet" href="dist/styles/materialize.min.css"  media="screen,projection"/>
	<link href="dist/styles/jquery-linedtextarea.css" type="text/css" rel="stylesheet" />
    <link rel="shortcut icon" href="dist/images/code.png">
    <link rel="stylesheet" href="dist/styles/Treant/Treant.css" type="text/css"/>
</head>
<body onload="init();">
	<!--Import jQuery before materialize.js-->
	<script type="text/javascript" src="dist/styles/jquery-3.3.1.min.js"></script>
	<script type="text/javascript" src="dist/styles/js/materialize.min.js"></script>
    <script type="text/javascript" src="dist/styles/js/jquery-linedtextarea.js"></script>
	<script>
		// for code input 
		$(function() {
			$(".lined").linedtextarea(
			);
		});
		// for modal
		$(document).ready(function(){
			// the "href" attribute of the modal trigger must specify the modal ID that wants to be triggered
			$('.modal').modal();
		});
		// for tooltip
		$(document).ready(function(){
			$('.tooltipped').tooltip({delay: 0});
		});
	</script>
	<main>
		<header>
			<div class="container">
				<h1 class="center-align">Kompailer</h1>
			</div>
		</header>
		<div class="container">
			<div class="row">
				<div class="col s6">
					<div class="card-panel input">
						<h5 class="light">Editor</h5>
						<textarea class="lined" id="taSourceCode">
/* Test case for all productions - thx Tien */
{
    /* Int Declaration */
    int a
    int b
    string s
    boolean z
    
    z = true
    s = "kai sucks"

    a = 0
    b = 0

    /* While Loop */
    while (a != 3) {
        print(a)
        while (b != 3) {
                print(b)
                b = 1 + b
                if (b == 2) {
                    /* Print Statement */
                    print("kai sucks"/* This will do nothing */)
                }
        }

        b = 0
        a = 1 + a
    }
}$
/* Second program with parse error */
{
    int a
    a = a + 2
}$
/* Third program with lex error */
{
    print("hello there")
    print("General Genobi")
}$
/* Fourth normal program */
{
    print("hello there")
    print("general kenobi")
}$
</textarea>
						<br>
						<div class="fixed-action-btn horizontal click-to-toggle togglebutton">
							<a class="btn-floating btn blue lighten-2">
								<i class="material-icons">navigate_next</i>
							</a>
							<ul style="left: 0">
								<!-- <li><a class="btn-floating red"><i class="material-icons">insert_chart</i></a></li>
								<li><a class="btn-floating yellow darken-1"><i class="material-icons">format_quote</i></a></li>
								<li><a class="btn-floating green"><i class="material-icons">publish</i></a></li>
								<li><a class="btn-floating blue"><i class="material-icons">attach_file</i></a></li> -->
								<li>
									<a href="#grammarModal" class="waves-effect waves-light blue lighten-3 btn-floating modal-trigger subfloatgrammar"/>Language Grammar</a>
								</li>
								<li>
									<a href="#casesModal" class="waves-effect waves-light blue lighten-3 btn-floating modal-trigger subfloattest"/>Test Cases</a>
								</li>
							</ul>
						</div>
					</div>
				</div>
				<div class="col s6">
					<div class="card-panel log">
						<h5 class="light">Log</h5>
						<textarea id="taOutput" readonly disabled></textarea>
						<a class="btn-floating btn waves-effect waves-light red right-align verbose tooltipped" id="verbose" data-position="bottom" data-delay="50" data-tooltip="Toggle Verbose Mode" onclick="btnVerbose_click();"><i class="material-icons">hearing</i></a>
					</div>
				</div>
			</div>
			<div class="row">
				<div class="center-align">
					<button type="button" id="btnCompile" value="Compile" class="waves-effect waves-light btn-large pulse" onclick="btnCompile_click();"/>Compile</button>
				</div>
			</div>	
			<br>
			<hr>
			<br>
			<div class="row">
				<div class="col s6">
					<ul class="tabs">
						<li class="tab col s3"><a class="active" href="#cst">CST</a></li>
						<li class="tab col s3"><a href="#ast">AST</a></li>
					</ul>
				</div>
				<div class="col s6"></div>
			</div>
			<div class="row">
				<div class="col s6">
					<div id="cst" class="card-panel log">
                        <h5 class="light">CST<a id="btnCST" value="cst" href="#visual-cst" class="waves-effect waves-light btn right" style="bottom: 5px"/>View Visual CST</a></h5>
						<textarea id="taCST" readonly disabled></textarea>
					</div>
					<div id="ast" class="card-panel log">
						<h5 class="light">AST</h5>
						<textarea id="taAST" readonly disabled></textarea>
					</div>
				</div>
				<div class="col s6">
					<div class="card-panel log">
						<h5 class="light">Symbol Table</h5>
						<table id="symbolTable" class="striped">
							<thead>
								<tr>
									<th>Key</th>
									<th>Type</th>
									<th>Scope</th>
									<th>Scope Level</th>
									<th>Line Number</th>
									<th>Col Number</th>
								</tr>
							</thead>
							<tbody>
									<tr></tr>

							</tbody>
						</table>
					</div>
				</div>
            </div>
			<div class="row">
                <div id="visual-cst" class="card-panel log">
                    <h5 class="light">Visual CST Representation</h5>
                    <div id="tree-cst" style="width: 100%; height: 500px"></div>
                </div>
            </div>
            <div class="row">
                <div id="visual-ast" class="card-panel log">
                    <h5 class="light">Visual AST Representation</h5>
                    <div id="tree-ast" style="width: 100%; height: 500px"></div>
                </div>
            </div>
		</div>

		<!-- Modal Structure -->
		<div id="grammarModal" class="modal">
			<div class="modal-content center-align">
				<img class="responsive-img center-align" src="dist/images/grammar.PNG">
			</div>
			<div class="modal-footer">
				<a class="modal-action modal-close waves-effect waves-green btn-flat">Close</a>
			</div>
        </div>
        <div id="cstModal" class="modal">
            <div class="modal-content center-align">
                <div id="tree-cst"></div>
            </div>
            <div class="modal-footer">
                <a class="modal-action modal-close waves-effect waves-green btn-flat">Close</a>
            </div>
        </div>
		<div id="casesModal" class="modal bottom-sheet">
			<div class="modal-content center-align">
				<ul class="collapsible center-align" data-collapsible="accordion">
					<li>
						<div class="collapsible-header"><i class="material-icons">brightness_5</i>Valid Cases</div>
						<div class="collapsible-body">
							<div class="collection">
								<a href="#!" onclick="TSC.Testcases.load(this);" class="collection-item modal-action modal-close">Simple 1</a>
								<a href="#!" onclick="TSC.Testcases.load(this);" class="collection-item modal-action modal-close">Simple 2</a>
								<a href="#!" onclick="TSC.Testcases.load(this);" class="collection-item modal-action modal-close">Regular</a>
                                <a href="#!" onclick="TSC.Testcases.load(this);" class="collection-item modal-action modal-close">Multiple</a>
                                <a href="#!" onclick="TSC.Testcases.load(this);" class="collection-item modal-action modal-close">All Productions thx Tien</a>
                                <a href="#!" onclick="TSC.Testcases.load(this);" class="collection-item modal-action modal-close">Crazy One Liner (Lex Pass)</a>
                                <a href="#!" onclick="TSC.Testcases.load(this);" class="collection-item modal-action modal-close">Crazy One Liner Pt. 2 Thx Tien</a>
                                <a href="#!" onclick="TSC.Testcases.load(this);" class="collection-item modal-action modal-close">WhileStatement</a>
                                <a href="#!" onclick="TSC.Testcases.load(this);" class="collection-item modal-action modal-close">IfStatement</a>
							</div>
						</div>
					</li>
					<li>
						<div class="collapsible-header"><i class="material-icons">warning</i>Warning Cases</div>
						<div class="collapsible-body">
							<div class="collection">
								<a href="#!" onclick="TSC.Testcases.load(this);" class="collection-item modal-action modal-close">Missing EOP</a>
							</div>
						</div>
					</li>
					<li>
						<div class="collapsible-header"><i class="material-icons">new_releases</i>Lex Error Cases</div>
						<div class="collapsible-body">
							<div class="collection">
								<a href="#!" onclick="TSC.Testcases.load(this);" class="collection-item modal-action modal-close">Alan</a>
								<a href="#!" onclick="TSC.Testcases.load(this);" class="collection-item modal-action modal-close">Invalid String 1</a>
								<a href="#!" onclick="TSC.Testcases.load(this);" class="collection-item modal-action modal-close">Invalid String 2</a>
								<a href="#!" onclick="TSC.Testcases.load(this);" class="collection-item modal-action modal-close">Invalid String 3</a>
								<a href="#!" onclick="TSC.Testcases.load(this);" class="collection-item modal-action modal-close">Invalid String 4</a>
								<a href="#!" onclick="TSC.Testcases.load(this);" class="collection-item modal-action modal-close">Invalid Print</a>
								<a href="#!" onclick="TSC.Testcases.load(this);" class="collection-item modal-action modal-close">Missing End Comment Brace</a>
							</div>
						</div>
                    </li>
                    <li>
						<div class="collapsible-header"><i class="material-icons">new_releases</i>Parse Error Cases</div>
						<div class="collapsible-body">
							<div class="collection">
								<a href="#!" onclick="TSC.Testcases.load(this);" class="collection-item modal-action modal-close">Invalid Expr</a>
								<a href="#!" onclick="TSC.Testcases.load(this);" class="collection-item modal-action modal-close">Invalid VarDecl</a>
								<a href="#!" onclick="TSC.Testcases.load(this);" class="collection-item modal-action modal-close">Invalid Print Pt. 2</a>
								<a href="#!" onclick="TSC.Testcases.load(this);" class="collection-item modal-action modal-close">Incomplete BooleanExpr</a>
								<a href="#!" onclick="TSC.Testcases.load(this);" class="collection-item modal-action modal-close">Incomplete IntExpr</a>
							</div>
						</div>
					</li>
				</ul>
            </div>
			<div class="modal-footer">
				<a class="modal-action modal-close waves-effect waves-green btn-flat">Close</a>
			</div>
		</div>
	</main>

	<footer class="page-footer blue">
		<div class="container">
			<div class="row">
			<div class="col l6 s12">
                <h5 class="white-text">A Compiler by Kai Wong</h5>
				<!-- <h5 class="white-text">Footer Content</h5> -->
				<!-- <p class="grey-text text-lighten-4">You can use rows and columns here to organize your footer content.</p> -->
			</div>
			<div class="col l4 offset-l2 s12">
				<!-- <h5 class="white-text">Links</h5> -->
				<ul>
				</ul>
			</div>
			</div>
		</div>
		<div class="footer-copyright">
			<div class="container">
			© 2018 Kai Wong
			<a class="grey-text text-lighten-4 right" target="_blank" href="https://github.com/Holayn">GitHub</a>
			</div>
		</div>
	</footer>


    <!-- Client-side code down here, per the YSlow advice. 
         (http://developer.yahoo.com/performance/rules.html#js_bottom) -->
	<script type="text/javascript" src="dist/scripts/utils.js"></script>	
	<script type="text/javascript" src="dist/scripts/lexer.js"></script>	
	<script type="text/javascript" src="dist/scripts/parser.js"></script>
	<script type="text/javascript" src="dist/scripts/globals.js"></script>	
	<script type="text/javascript" src="dist/scripts/token.js"></script>
	<script type="text/javascript" src="dist/scripts/error.js"></script>	
	<script type="text/javascript" src="dist/scripts/warning.js"></script>	
	<script type="text/javascript" src="dist/scripts/testcases.js"></script>
	<script type="text/javascript" src="dist/scripts/tree.js"></script>
	<script type="text/javascript" src="dist/styles/Treant/vendor/raphael.js"></script>
    <script type="text/javascript" src="dist/styles/Treant/Treant.js"></script>
    <script type="text/javascript" src="dist/scripts/semanticAnalyzer.js"></script>
    <script type="text/javascript" src="dist/scripts/scope.js"></script>
	<script type="text/javascript">
	
        var verboseOn = true;

		function init() {
            // Clear the log and the CST.
			document.getElementById("taOutput").value = "";
			document.getElementById("taCST").value = "";
			// Clear symbol table
			var table = document.getElementById("symbolTable");
			// Leave header in place
			var rowCount = table.rows.length;
			for (var i = rowCount - 1; i > 1; i--) {
				table.deleteRow(i);
			}
	        // Set the initial values for our globals.
	        tokens = "";
	        tokenIndex = 0;
	        currentToken = ' ';
			errorCount = 0;        
			// Clear visual CST
			var cst_visual = new Treant({
				chart: {
					container: "#tree-cst"
				},
				nodeStructure: {}
            });
            var ast_visual = new Treant({
				chart: {
					container: "#tree-ast"
				},
				nodeStructure: {}
			});
		}
		
		function btnVerbose_click() {
			var element = document.getElementById('verbose');
			if(element.style.backgroundColor == 'lightgrey'){
				element.setAttribute('style', 'background-color: red !important');
			}
			else{
				element.setAttribute('style', 'background-color: lightgrey !important');
			}
			if(verboseOn){
				verboseOn = false;
			}
			else{
				verboseOn = true;
			}
			console.log(verboseOn);
			
		}

	    function btnCompile_click() {        
	        // This is executed as a result of the user pressing the 
	        // "compile" button between the two text areas, above.  
	        // Note the <input> element's event handler: onclick="btnCompile_click();
            init();

            // Compile the source code
            compile();
			
			// Scroll to bottom of the log
			var textarea = document.getElementById('taOutput');
			textarea.scrollTop = textarea.scrollHeight;
	    }
    
	    function putMessage(msg) {
	        document.getElementById("taOutput").value += msg + "\n";
        }
        
        function compile() {
            // Lex the source code
            // Construct new lexer
            let lexer = new TSC.Lexer();
            // Lex program
            var isLexComplete = false; // flag for completion of lex
            var programCounter = 1; // counter for number of programs compiled
            var lexAnalysis; // object returned by lexer
			var programDetected = false; // flag for program detection
			var prevProgramError = false; // flag to keep track if previous program in sequence of programs had error
			
			// Base Treant.js CST config
			// Declaring it here and passing it to calls of parse will allow
			// the tree to support compilation of multiple programs
			var treantCST = {
				chart: {
					container: "#tree-cst"
				},
				
				nodeStructure: {
					text: { name: "Root" },
					children: [
					]
				}
            };
            var treantAST = {
				chart: {
					container: "#tree-ast"
				},
				
				nodeStructure: {
					text: { name: "Root" },
					children: [
					]
				}
			};

            // We're compiling programs in sequence.
            // For every program, lex, parse, perform semantic analysis, etc...
            while(!isLexComplete){
				console.log("Starting another lex");
				lexAnalysis = lexer.lex(prevProgramError);
				console.log(lexAnalysis);
				// Attempt to lex . . 
				// If we get an error, report it
				// Then, try to lex again by having lexer look for next EOP token, then lexing from there
				// If no error, parse. Then lex next program
				// If reach end of source code and no tokens, throw error
				if(lexAnalysis.errors.length != 0){
					programDetected = true; // we know a program was detected, aka user actually typed code besides comments
					putMessage("______________________________");
					putMessage("Compiling Program " + programCounter + " . . .\n");
					logLex(lexAnalysis, programCounter);
					programCounter++;
					prevProgramError = true;
					putMessage("Parser skipped due to Lexer errors . . ");
				}
				// No tokens were found but lex completed, meaning that there is no more input to lex
				else if(lexAnalysis.tokens.length == 0){
					isLexComplete = true;
				}
				else{
					programDetected = true; // we know a program was detected, aka user actually typed code besides comments
					putMessage("______________________________");
					putMessage("Compiling Program " + programCounter + " . . .\n");
					logLex(lexAnalysis, programCounter);
					prevProgramError = false;
                    var parseResult = parse(lexAnalysis, treantCST, programCounter);
                    analyze(parseResult, treantAST, programCounter); // perform semantic analysis on the cst from the parse
                    programCounter++;
				}
				if(lexAnalysis.complete){
					isLexComplete = true;
				}
				// If the user tried to compile without typing any code besides comments, throw error
				if(!programDetected){
					putMessage("Why are you trying to compile zero code? Cheese and crackers you dimwit go eat a sock.");
				}
            }
        }
		
		// Fills log with messages from lexer
		function logLex(lexAnalysis, programCounter) {
			putMessage("Lexical Analysis:");
			// For all tokens, print out their type and value..only if verbose mode is on
			if(verboseOn){
				for(var i=0; i<lexAnalysis.tokens.length; i++){
					putMessage("LEXER -> | " + lexAnalysis.tokens[i].type + " [ " + lexAnalysis.tokens[i].value + " ] on line " + lexAnalysis.tokens[i].lineNumber + " col " + lexAnalysis.tokens[i].colNumber);
				}
			}
			// Print any warnings and errors
			for(var i=0; i<lexAnalysis.warnings.length; i++){
				if(lexAnalysis.warnings[i].type == TSC.WarningType.MissingEOP){
					putMessage("LEXER -> | WARNING: No EOP [$] detected at end-of-file. Adding to end-of-file...");
					// Insert an EOP into the tokens array
					lexAnalysis.tokens.push(new TSC.Token(TSC.TokenType.TEop, "$", lexAnalysis.line, lexAnalysis.col));
				}
			}
			for(var i=0; i<lexAnalysis.errors.length; i++){
				if(lexAnalysis.errors[i].type == TSC.ErrorType.InvalidToken){
					putMessage("LEXER -> | ERROR: Unrecognized or Invalid Token [ " + lexAnalysis.errors[i].value + " ] on line " + lexAnalysis.errors[i].lineNumber + " col " + lexAnalysis.errors[i].colNumber);
				}
				else if(lexAnalysis.errors[i].type == TSC.ErrorType.MissingCommentEnd){
					putMessage("LEXER -> | ERROR: Missing ending comment brace (*/) for comment starting on line  " + lexAnalysis.errors[i].lineNumber + " col " + lexAnalysis.errors[i].colNumber);
				}
				else if(lexAnalysis.errors[i].type == TSC.ErrorType.InvalidCharacterInString){
					putMessage("LEXER -> | ERROR: Invalid character in String [ " + lexAnalysis.errors[i].value + " ] on line " + lexAnalysis.errors[i].lineNumber + " col " + lexAnalysis.errors[i].colNumber);
				}
				else if(lexAnalysis.errors[i].type == TSC.ErrorType.MissingStringEndQuote){
					putMessage("LEXER -> | ERROR: Missing ending quote for String literal starting on line  " + lexAnalysis.errors[i].lineNumber + " col " + lexAnalysis.errors[i].colNumber);
				}
			}
			// Display toasts for warnings and errors
			if(lexAnalysis.warnings.length > 0){
				Materialize.toast('Program ' + programCounter + ': Lex warning!', 4000, 'toastcolor');
			}
			if(lexAnalysis.errors.length > 0){
				Materialize.toast('Program ' + programCounter + ': Lex error!', 4000, 'toastcolor');
			}
			putMessage("\n");
			putMessage("Lexical Analysis complete! " + lexAnalysis.warnings.length + " WARNING(S) and " + lexAnalysis.errors.length + " ERROR(S)");
			putMessage("-------------------------");
		}
		
		// Takes tokens from lexical analysis and passes them to parser
		// Also passes Treant CST config so parser can construct CST or add on to existing CST
	    function parse(lexAnalysis, treantCST, programCounter) {
			putMessage("Parsing...");
			// Put tokens into parser for validation
			let parser = new TSC.Parser(lexAnalysis.tokens);
			// Gets log and cst generated by parser
			var res = parser.parse();
			// Display log in log
			if(verboseOn){
				for(var i=0; i<res.log.length; i++){
					putMessage("PARSER -> | " + res.log[i]);
				}
			}
			// Parse fail, do not print CST
			if(res.error){
				putMessage("\n");
                putMessage("Parse failed due to error.");
                putMessage("CST generation failed due to parse error.");
				Materialize.toast('Program ' + programCounter + ': Parse error!', 4000, 'toastcolor');
			}
			else{
				putMessage("\n");
				putMessage("Parse completed successfully! 0 ERRORS");
				putMessage("-------------------------");
				// Traverses the CST generated by the parser and displays in CST field
				var cst = res.cst.traverseTreeCST(treantCST);
				for(var i=0; i<cst.tree.length; i++){
					document.getElementById("taCST").value += cst.tree[i] + "\n";
                }
                // Display CST visually with Treant.js
                var cst_visual = new Treant(cst.treant);
            }
            // Return the results of the parser so the cst can be used by the semantic analyzer
            return res;
        }

        // Calls the semantic analyzer
        function analyze(parseResult, treantAST, programCounter) {
            putMessage("Performing Semantic Analysis...\n");
            let semanticAnalyzer = new TSC.SemanticAnalyzer();
			var res = semanticAnalyzer.analyze(parseResult);
			// Display AST regardless of error
			var ast = res.ast.traverseTreeAST(treantAST);
			// Display AST in AST field
			for(var i=0; i<ast.tree.length; i++){
				document.getElementById("taAST").value += ast.tree[i] + "\n";
			}
			// Display AST visually with Treant.js
			var ast_visual = new Treant(ast.treant);
			// Print log messages if verbose on
			if(verboseOn){
				for(var i=0; i<res.log.length; i++){
					putMessage("S.ANALYZE -> | " + res.log[i]);
				}
			}
			// Print warnings
			putMessage("\n");
			for(var i=0; i<res.warnings.length; i++){
				var warningMsg = res.warnings[i];
				console.log(warningMsg);
				switch(warningMsg.type){
					case TSC.WarningType.UninitializedVariable:
						// putMessage("S.ANALYZE -> | WARNING: Variable [" + warningMsg.value + "] on line " + warningMsg.lineNumber + " col " + warningMsg.colNumber + " has been declared but is not initialized properly in scope " + warningMsg.scopeId + " on line " + warningMsg.scopeLine + " col " + warningMsg.scopeCol);
						putMessage("S.ANALYZE -> | WARNING: Variable [" + warningMsg.value + "] on line " + warningMsg.lineNumber + " col " + warningMsg.colNumber + " has been declared but is not initialized properly.");
						break;
					case TSC.WarningType.UnusedVariable:
						// putMessage("S.ANALYZE -> | WARNING: Variable [" + warningMsg.value + "] on line " + warningMsg.lineNumber + " col " + warningMsg.colNumber + " has been initialized in scope " + warningMsg.scopeId + " on line " + warningMsg.scopeLine + " col " + warningMsg.scopeCol + " but is not used in scope " + warningMsg.scopeId);
						putMessage("S.ANALYZE -> | WARNING: Variable [" + warningMsg.value + "] on line " + warningMsg.lineNumber + " col " + warningMsg.colNumber + " has been initialized but is not used.");
						break;
				}
				Materialize.toast('Program ' + programCounter + ': Semantic warning!', 4000, 'toastcolor');
			}
			if(res.error){
				// Print errors
				for(var i=0; i<res.errors.length; i++){
					var errorMsg = res.errors[i];
					console.log(errorMsg);
					switch(errorMsg.type){
						case TSC.ErrorType.DuplicateVariable:
							putMessage("S.ANALYZE -> | ERROR: Variable [" + errorMsg.value.value + "] on line " + errorMsg.lineNumber + " col " + errorMsg.colNumber + " has already been declared in current scope at line " + errorMsg.firstDeclareLine + " col " + errorMsg.firstDeclareCol);
							break;
						case TSC.ErrorType.UndeclaredVariable:
							putMessage("S.ANALYZE -> | ERROR: Variable [" + errorMsg.value.value + "] on line " + errorMsg.lineNumber + " col " + errorMsg.colNumber + " has not been previously declared.");
							break;
						case TSC.ErrorType.TypeMismatch:
							putMessage("S.ANALYZE -> | ERROR: The variable [" + errorMsg.value.value + "] declared on line " + errorMsg.lineNumber + " col " + errorMsg.colNumber + " is of type " + errorMsg.idType.value + " and does not match the assignment type of " + errorMsg.targetType);
							break;
						case TSC.ErrorType.IncorrectTypeComparison:
							putMessage("S.ANALYZE -> | ERROR: The [" + errorMsg.value + "] on line " + errorMsg.lineNumber + " col " + errorMsg.colNumber + " is of type " + errorMsg.idType + " and is incompatibly compared to a type of " + errorMsg.targetType);
							break;
					}
				}
				putMessage("\n");
				Materialize.toast('Program ' + programCounter + ': Semantic error!', 4000, 'toastcolor');
			}
			else{
				// Display symbols in Symbol Table
				var symbols = res.symbols;
				for(var i=0; i<symbols.length; i++){
					var table = document.getElementById("symbolTable");
					var row = table.insertRow(-1);
					var key = row.insertCell(0);
					key.innerHTML = symbols[i].key;
					var type = row.insertCell(1);
					type.innerHTML = symbols[i].type;
					var scope = row.insertCell(2);
					scope.innerHTML = symbols[i].scope;
					var scopeLevel = row.insertCell(3);
					scopeLevel.innerHTML = symbols[i].scopeLevel;
					var lineNumber = row.insertCell(4);
					lineNumber.innerHTML = symbols[i].line;
					var colNumber = row.insertCell(5);
					colNumber.innerHTML = symbols[i].col;
				}
			}
			putMessage("Semantic Analysis complete! " + res.errors.length + " ERROR(S)");
        }
		
    
    </script>
</body>
</html>