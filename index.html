<!DOCTYPE HTML>
<html>
<head>
    <title>Kompailer</title>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <link rel="stylesheet" type="text/css" href="dist/styles/compiler.css" />
	<!-- <link rel="stylesheet" href="dist/styles/bootstrap.min.css"> -->
	<!--Import Google Icon Font-->
	<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
	<!--Import materialize.css-->
	<link type="text/css" rel="stylesheet" href="dist/styles/materialize.min.css"  media="screen,projection"/>
	<link href="dist/styles/jquery-linedtextarea.css" type="text/css" rel="stylesheet" />
</head>
<body onload="init();">
	<!--Import jQuery before materialize.js-->
	<script type="text/javascript" src="dist/styles/jquery-3.3.1.min.js"></script>
	<script type="text/javascript" src="dist/styles/js/materialize.min.js"></script>
	<script type="text/javascript" src="dist/styles/js/jquery-linedtextarea.js"></script>
	<script>
		$(function() {
			$(".lined").linedtextarea(
			);
		});
		$(document).ready(function(){
			// the "href" attribute of the modal trigger must specify the modal ID that wants to be triggered
			$('.modal').modal();
		});
	</script>
	<main>
		<header>
			<div class="container">
				<h1 class="center-align">Kompailer</h1>
			</div>
		</header>
		<div class="container">
			<div class="row">
				<div class="col s6">
					<div class="card-panel input">
						<h5 class="light">Editor</h5>
						<textarea class="lined" id="taSourceCode" rows="60">+${hellotruefalsetrueprintwhileiftruefalsestring!= stringintboolean truewhileif{hi+++==!=}}/*aaahaha*/hahahahaha/*awao*/$</textarea>
						<br>
						<a href="#grammarModal" class="waves-effect waves-light blue lighten-3 btn modal-trigger"/>View Language Grammar</a>
						<a href="#casesModal" class="waves-effect waves-light blue lighten-3 btn modal-trigger"/>Test Cases</a>
					</div>
				</div>
				<div class="col s6">
					<div class="card-panel log">
						<h5 class="light">Log</h5>
						<textarea id="taOutput" readonly disabled></textarea>
					</div>
				</div>
			</div>
			<div class="row">
				<div class="center-align">
					<button type="button" id="btnCompile" value="Compile" class="waves-effect waves-light btn-large" onclick="btnCompile_click();"/>Compile</button>
				</div>
			</div>	
		</div>

		<!-- Modal Structure -->
		<div id="grammarModal" class="modal">
			<div class="modal-content center-align">
				<img class="responsive-img center-align" src="dist/images/grammar.PNG">
			</div>
			<div class="modal-footer">
				<a class="modal-action modal-close waves-effect waves-green btn-flat">Close</a>
			</div>
		</div>
		<div id="casesModal" class="modal bottom-sheet">
			<div class="modal-content center-align">
				<ul class="collapsible" data-collapsible="accordion">
					<li>
						<div class="collapsible-header"><i class="material-icons">brightness_5</i>Valid Cases</div>
						<div class="collapsible-body"><span>Lorem ipsum dolor sit amet.</span></div>
					</li>
					<li>
						<div class="collapsible-header"><i class="material-icons">warning</i>Warning Cases</div>
						<div class="collapsible-body"><span>Lorem ipsum dolor sit amet.</span></div>
					</li>
					<li>
						<div class="collapsible-header"><i class="material-icons">new_releases</i>Lex Error Cases</div>
						<div class="collapsible-body"><span>Lorem ipsum dolor sit amet.</span></div>
					</li>
				</ul>
			</div>
			<div class="modal-footer">
				<a class="modal-action modal-close waves-effect waves-green btn-flat">Close</a>
			</div>
		</div>
	</main>

	<footer class="page-footer blue">
		<div class="container">
			<div class="row">
			<div class="col l6 s12">
				<!-- <h5 class="white-text">Footer Content</h5> -->
				<!-- <p class="grey-text text-lighten-4">You can use rows and columns here to organize your footer content.</p> -->
			</div>
			<div class="col l4 offset-l2 s12">
				<!-- <h5 class="white-text">Links</h5> -->
				<ul>
				</ul>
			</div>
			</div>
		</div>
		<div class="footer-copyright">
			<div class="container">
			Â© 2018 Kai Wong
			<!-- <a class="grey-text text-lighten-4 right" href="#!">More Links</a> -->
			</div>
		</div>
	</footer>


    <!-- Client-side code down here, per the YSlow advice. 
         (http://developer.yahoo.com/performance/rules.html#js_bottom) -->
    <script type="text/javascript" src="dist/scripts/utils.js"></script>	
    <script type="text/javascript" src="dist/scripts/lexer.js"></script>	
	<script type="text/javascript" src="dist/scripts/globals.js"></script>	
	<script type="text/javascript" src="dist/scripts/token.js"></script>
	<script type="text/javascript" src="dist/scripts/error.js"></script>	
	<script type="text/javascript" src="dist/scripts/warning.js"></script>	
    <script type="text/javascript">
		 function init() {
	        // Clear the message box.
	        document.getElementById("taOutput").value = "";
	        // Set the initial values for our globals.
	        tokens = "";
	        tokenIndex = 0;
	        currentToken = ' ';
	        errorCount = 0;        
	    }
    
	    function btnCompile_click() {        
	        // This is executed as a result of the user pressing the 
	        // "compile" button between the two text areas, above.  
	        // Note the <input> element's event handler: onclick="btnCompile_click();
	        init();
			putMessage("Lexical Analysis:");
	        // Grab the tokens from the lexer . . .
			var lexAnalysis = _Lexer.lex();
			console.log(lexAnalysis);
			// For all tokens, print out their type and value
			for(var i=0; i<lexAnalysis.tokens.length; i++){
				putMessage("LEXER -> | " + lexAnalysis.tokens[i].type + " [ " + lexAnalysis.tokens[i].value + " ] on line " + lexAnalysis.tokens[i].lineNumber);
			}
			// Print any warnings and errors
			for(var i=0; i<lexAnalysis.warnings.length; i++){
				if(lexAnalysis.warnings[i].type == TSC.WarningType.MissingEOP){
					putMessage("LEXER -> | WARNING: No EOP [$] detected at end-of-file. Adding to end-of-file...");
					// Insert an EOP into the tokens array
					lexAnalysis.tokens.push(new TSC.Token(TSC.TokenType.TEop, "$"));
				}
			}
			for(var i=0; i<lexAnalysis.errors.length; i++){
				if(lexAnalysis.errors[i].type == TSC.ErrorType.InvalidToken){
					putMessage("LEXER -> | ERROR: Unrecognized or Invalid Token [ " + lexAnalysis.errors[i].value + " ] on line " + lexAnalysis.errors[i].lineNumber);
				}
				else if(lexAnalysis.errors[i].type == TSC.ErrorType.MissingCommentEnd){
					putMessage("LEXER -> | ERROR: Missing ending comment brace (*/)");
				}
			}
			putMessage("Lexical Analysis complete! " + lexAnalysis.warnings.length + " WARNING(S) and " + lexAnalysis.errors.length + " ERROR(S)");
	        // . . . and parse!
			// parse();
			// Scroll to bottom of the log
			var textarea = document.getElementById('taOutput');
			textarea.scrollTop = textarea.scrollHeight;
	    }
    
	    function putMessage(msg) {
	        document.getElementById("taOutput").value += msg + "\n";
	    }
    
    
	 	 // TODO: These parse routines really should be in TypeScript.
		 //       This exercise is left to the read. Consider it project 0.5 .
	    function parse() {
	        putMessage("Parsing [" + tokens + "]");
	        // Grab the next token.
	        currentToken = getNextToken();
	        // A valid parse derives the G(oal) production, so begin there.
	        parseG();
	        // Report the results.
	        putMessage("Parsing found " + errorCount + " error(s).");        
	    }
    
	    function parseG() {
	        // A G(oal) production can only be an E(xpression), so parse the E production.
	        parseE();
	    }

	    function parseE() {
	        // All E productions begin with a digit, so make sure that we have one.
	        checkToken("digit");
	        // Look ahead 1 char (which is now in currentToken because checkToken 
	        // consumes another one) and see which E production to follow.
	        if (currentToken != EOF) {
	            // We're not done, we expect to have an op.
	            checkToken("op");
	            parseE();
	        } else {
	            // There is nothing else in the token stream, 
	            // and that's cool since E --> digit is valid.
	            putMessage("EOF reached");
	        }
	    }

	    function checkToken(expectedKind) {
	        // Validate that we have the expected token kind and et the next token.
	        switch(expectedKind) {
	            case "digit":   putMessage("Expecting a digit");
	                            if (currentToken=="0" || currentToken=="1" || currentToken=="2" || 
	                                currentToken=="3" || currentToken=="4" || currentToken=="5" || 
	                                currentToken=="6" || currentToken=="7" || currentToken=="8" || 
	                                currentToken=="9")
	                            {
	                                putMessage("Got a digit!");
	                            }
	                            else
	                            {
	                                errorCount++;
	                                putMessage("NOT a digit.  Error at position " + tokenIndex + ".");
	                            }
	                            break;
	            case "op":      putMessage("Expecting an operator");
	                            if (currentToken=="+" || currentToken=="-")
	                            {
	                                putMessage("Got an operator!");
	                            }
	                            else
	                            {
	                                errorCount++;
	                                putMessage("NOT an operator.  Error at position " + tokenIndex + ".");
	                            }
	                            break;
	            default:        putMessage("Parse Error: Invalid Token Type at position " + tokenIndex + ".");
	                            break;			
	        }
	        // Consume another token, having just checked this one, because that 
	        // will allow the code to see what's coming next... a sort of "look-ahead".
	        currentToken = getNextToken();
	    }

	    function getNextToken() {
	        var thisToken = EOF;    // Let's assume that we're at the EOF.
	        if (tokenIndex < tokens.length)
	        {
	            // If we're not at EOF, then return the next token in the stream and advance the index.
	            thisToken = tokens[tokenIndex];
	            putMessage("Current token:" + thisToken);
	            tokenIndex++;
	        }
	        return thisToken;
	    }
    </script>
</body>
</html>